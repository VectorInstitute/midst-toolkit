from collections.abc import Callable
from dataclasses import dataclass
from enum import Enum
from typing import Any, Self

import numpy as np
from torch import nn


# TODO: Temporary, will switch to classes later
Configs = dict[str, Any]
Tables = dict[str, dict[str, Any]]
RelationOrder = list[tuple[str, str]]
GroupLengthsProbDicts = dict[tuple[str, str], dict[int, dict[int, float]]]
ArrayDict = dict[str, np.ndarray]
ModuleType = str | Callable[..., nn.Module]


class ClusteringMethod(Enum):
    """Possioble clustering methods for multi-table training."""

    KMEANS = "kmeans"
    GMM = "gmm"
    KMEANS_AND_GMM = "kmeans_and_gmm"
    VARIATIONAL = "variational"


class IsYCond(Enum):
    """
    The condition on the y column.

    IsYCond.CONCAT: y is concatenated to X, the model learn a joint distribution of (y, X)
    IsYCond.EMBEDDING: y is not concatenated to X. During computations, y is embedded
        and added to the latent vector of X
    IsYCond.NONE: y column is completely ignored

    How does is_y_cond affect the generation of y?
    is_y_cond:
        IsYCond.CONCAT: the model synthesizes (y, X) directly, so y is just the first column
        IsYCond.EMBEDDING: y is first sampled using empirical distribution of y. The model only
            synthesizes X. When returning the generated data, we return the generated X
            and the sampled y. (y is sampled from empirical distribution, instead of being
            generated by the model)
            Note that in this way, y is still not independent of X, because the model has been
            adding the embedding of y to the latent vector of X during computations.
        IsYCond.NONE:
            y is synthesized using y's empirical distribution. X is generated by the model.
            In this case, y is completely independent of X.
    """

    CONCAT = "concat"
    EMBEDDING = "embedding"
    NONE = "none"


@dataclass
class RTDLParameters:
    """Parameters for the RTDL model."""

    d_layers: list[int]
    dropout: float
    d_in: int = 0
    d_out: int = 0
    emb_d: int = 0
    n_blocks: int = 0
    d_main: int = 0
    d_hidden: int = 0
    dropout_first: float = 0
    dropout_second: float = 0


@dataclass
class ModelParameters:
    """Parameters for the ClavaDDPM model."""

    rtdl_parameters: RTDLParameters
    d_in: int = 0
    num_classes: int = 0
    is_y_cond: IsYCond = IsYCond.NONE


class GaussianLossType(Enum):
    """Possible types of Gaussian loss."""

    MSE = "mse"
    KL = "kl"


class Scheduler(Enum):
    """Possible types of scheduler."""

    COSINE = "cosine"
    LINEAR = "linear"


class ReductionMethod(Enum):
    """Possible methods of reduction."""

    MEAN = "mean"
    SUM = "sum"
    NONE = "none"


class Normalization(Enum):
    """Possible types of normalization."""

    STANDARD = "standard"
    QUANTILE = "quantile"
    MINMAX = "minmax"


class NumNanPolicy(Enum):
    """Possible types of num nan policy."""

    DROP_ROWS = "drop-rows"
    MEAN = "mean"


class CatNanPolicy(Enum):
    """Possible types of cat nan policy."""

    MOST_FREQUENT = "most_frequent"


class CatEncoding(Enum):
    """Possible types of cat encoding."""

    ONE_HOT = "one-hot"
    COUNTER = "counter"
    ORDINAL = "ordinal"


class YPolicy(Enum):
    """Possible types of y policy."""

    DEFAULT = "default"


class TaskType(Enum):
    BINCLASS = "binclass"
    MULTICLASS = "multiclass"
    REGRESSION = "regression"

    def __str__(self) -> str:
        """
        Return the string representation of the task type, which is the value of the enum.

        Returns:
            The string representation of the task type.
        """
        return self.value


class PredictionType(Enum):
    LOGITS = "logits"
    PROBS = "probs"


@dataclass(frozen=True)
class Transformations:
    seed: int = 0
    normalization: Normalization | None = None
    num_nan_policy: NumNanPolicy | None = None
    cat_nan_policy: CatNanPolicy | None = None
    cat_min_frequency: float | None = None
    cat_encoding: CatEncoding | None = CatEncoding.ORDINAL
    y_policy: YPolicy | None = YPolicy.DEFAULT

    @classmethod
    def default(cls) -> Self:
        """Return the default transformations."""
        return cls(seed=0, normalization=Normalization.QUANTILE, y_policy=YPolicy.DEFAULT)
